<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì›ìˆ­ì´ì˜ ì‚°ë¶ˆ íƒˆì¶œ - ì—…ê·¸ë ˆì´ë“œ ë²„ì „</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            text-align: center;
            position: relative;
        }
        
        #gameCanvas {
            border: 3px solid #8B4513;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0,0,0,0.4);
            background: linear-gradient(to bottom, #87CEEB 0%, #90EE90 70%, #8B4513 100%);
        }
        
        #gameInfo {
            margin-top: 10px;
            font-size: 18px;
            color: #333;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .controls {
            margin-top: 10px;
            padding: 15px;
            background: rgba(255,255,255,0.9);
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        #miniGameOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 1000;
            border: 3px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }
        
        #miniGameKey {
            font-size: 80px;
            color: #FFD700;
            margin: 20px 0;
            font-weight: bold;
            text-shadow: 0 0 20px #FFD700;
        }
        
        #miniGameTimer {
            font-size: 28px;
            color: #FF6B6B;
            margin: 15px 0;
            font-weight: bold;
        }
        
        #miniGameInstruction {
            font-size: 20px;
            margin: 15px 0;
            color: #87CEEB;
        }
        
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        #startContent {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        
        .difficulty-btn {
            margin: 10px;
            padding: 15px 25px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .easy { background: #90EE90; }
        .normal { background: #FFD700; }
        .hard { background: #FF6B6B; color: white; }
        
        .difficulty-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        #settingsPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 10px;
            display: none;
        }
        
        .powerup {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .fire-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #FF4500;
            border-radius: 50%;
            animation: float 2s infinite;
        }
        
        @keyframes float {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-50px) rotate(360deg); opacity: 0; }
        }
        
        /* PCì—ì„œ ê°€ìƒ í‚¤ë³´ë“œ ìˆ¨ê¸°ê¸° */
        @media (min-width: 769px) {
            #numberPad, #letterPad {
                display: none !important;
            }
        }
        
        /* ëª¨ë°”ì¼ í„°ì¹˜ ìµœì í™” */
        @media (max-width: 768px) {
            #miniGameOverlay {
                width: 90%;
                max-width: 400px;
                padding: 20px;
            }
            
            #miniGameKey {
                font-size: 60px;
            }
            
            #miniGameTimer {
                font-size: 24px;
            }
            
            #miniGameInstruction {
                font-size: 18px;
            }
            
            /* í„°ì¹˜ ë²„íŠ¼ ìµœì í™” */
            button {
                min-height: 44px; /* iOS ê¶Œì¥ í„°ì¹˜ í¬ê¸° */
                touch-action: manipulation;
            }
            
            /* ìˆ«ì íŒ¨ë“œ ë²„íŠ¼ */
            #numberPad button {
                width: 50px;
                height: 50px;
                font-size: 20px;
                margin: 3px;
            }
            
            /* ì•ŒíŒŒë²³ íŒ¨ë“œ ë²„íŠ¼ */
            #letterPad button {
                width: 35px;
                height: 35px;
                font-size: 14px;
                margin: 2px;
            }
            
            /* ìƒ‰ê¹” ë²„íŠ¼ */
            #colorButtons button {
                width: 50px;
                height: 50px;
                margin: 3px;
            }
            
            /* ìˆ«ì ìˆœì„œ ë²„íŠ¼ */
            #numberButtons button {
                width: 50px;
                height: 50px;
                font-size: 20px;
                margin: 3px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>ğŸ’ ì›ìˆ­ì´ì˜ ì‚°ë¶ˆ íƒˆì¶œ ğŸƒâ€â™‚ï¸</h1>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="gameInfo">
            <div>ì²´ë ¥: <span id="health">100</span> | ì ìˆ˜: <span id="score">0</span> | ë‚˜ë¬´: <span id="treeCount">1</span> | ë ˆë²¨: <span id="level">1</span></div>
            <div>ìµœê³ ì ìˆ˜: <span id="highScore">0</span> | ì½¤ë³´: <span id="combo">0</span> | ë°”ë‚˜ë‚˜: <span id="bananaCount">0</span> | <span id="invincibilityStatus">ë¬´ì  ì•„ì´í…œ ì—†ìŒ</span></div>
        </div>
        <div class="controls">
            <strong>ê²Œì„í”Œë ˆì´:</strong> ì™„ì „ ìë™ ê²Œì„! ì›ìˆ­ì´ê°€ ë‚˜ë¬´ ìœ„ì—ì„œ ìë™ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤!<br>
            <strong>ë¯¸ë‹ˆê²Œì„:</strong> ë‚˜ë¬´ê°€ ë¶ˆì— íƒ€ë©´ ìë™ìœ¼ë¡œ ë¯¸ë‹ˆê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤! ë¶€ë“œëŸ¬ìš´ ì í”„ë¡œ ë‹¤ìŒ ë‚˜ë¬´ë¡œ ì´ë™! | ESC: ì¼ì‹œì •ì§€
        </div>
    </div>

    <!-- ì‹œì‘ í™”ë©´ -->
    <div id="startScreen">
        <div id="startContent">
            <h1>ğŸ’ ì›ìˆ­ì´ì˜ ì‚°ë¶ˆ íƒˆì¶œ ğŸƒâ€â™‚ï¸</h1>
            <p>ì‚°ë¶ˆì„ í”¼í•´ ë¬´í•œí•œ ë‚˜ë¬´ë“¤ì„ ê±´ë„ˆë©° ìƒì¡´í•˜ì„¸ìš”!</p>
            <h3>ë¯¸ë‹ˆê²Œì„ ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”:</h3>
            <button class="difficulty-btn easy" onclick="startGame('easy')">ì‰¬ì›€ (5ì´ˆ/ë¬¸ì œ)</button>
            <button class="difficulty-btn normal" onclick="startGame('normal')">ë³´í†µ (3ì´ˆ/ë¬¸ì œ)</button>
            <button class="difficulty-btn hard" onclick="startGame('hard')">ì–´ë ¤ì›€ (2ì´ˆ/ë¬¸ì œ)</button>
            <div id="settingsPanel">
                <label><input type="checkbox" id="soundToggle" checked> ì‚¬ìš´ë“œ</label>
                <label><input type="checkbox" id="musicToggle" checked> ìŒì•…</label>
            </div>
        </div>
    </div>

    <!-- ë¯¸ë‹ˆê²Œì„ ì˜¤ë²„ë ˆì´ -->
    <div id="miniGameOverlay">
        <h2 id="miniGameTitle">ğŸ¯ ë‚˜ë¬´ ê±´ë„ˆê¸° ë„ì „!</h2>
        <div id="miniGameInstruction">ë„ì „ ê³¼ì œë¥¼ ì™„ë£Œí•˜ì„¸ìš”!</div>
        <div id="miniGameContent"></div>
        <div id="miniGameTimer">3.0ì´ˆ</div>
    </div>

    <script>
        // ê²Œì„ ìº”ë²„ìŠ¤ ì„¤ì •
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ê²Œì„ ìƒíƒœ
        let gameState = {
            running: false,
            paused: false,
            score: 0,
            highScore: localStorage.getItem('monkeyHighScore') || 0,
            health: 100,
            timeLeft: 60,
            gameOver: false,
            treeCount: 1,
            level: 1,
            combo: 0,
            bananasCollected: 0, // ë°”ë‚˜ë‚˜ ìˆ˜ì§‘ ì¹´ìš´íŠ¸
            difficulty: 'normal',
            miniGameActive: false,
            miniGameType: '',
            miniGameTimer: 3.0,
            miniGameSuccess: false,
            soundEnabled: true,
            musicEnabled: true,
            cameraX: 0,  // í™”ë©´ ìŠ¤í¬ë¡¤ì„ ìœ„í•œ ì¹´ë©”ë¼ X ìœ„ì¹˜
            autoMoveSpeed: 2,  // ìë™ ì´ë™ ì†ë„
            nextTreeReady: false,  // ë‹¤ìŒ ë‚˜ë¬´ë¡œ ì´ë™í•  ì¤€ë¹„ê°€ ë˜ì—ˆëŠ”ì§€
            fireSpreadTime: 0  // ì‚°ë¶ˆì´ ë²ˆì§€ëŠ” ì‹œê°„
        };
        
        // ì›ìˆ­ì´ ìºë¦­í„°
        const monkey = {
            x: 100,
            y: 300,  // ë‚˜ë¬´ ìœ„ì—ì„œ ì‹œì‘
            width: 40,
            height: 50,
            velocityX: 0,
            velocityY: 0,
            onTree: true,  // ë‚˜ë¬´ ìœ„ì— ìˆìŒ
            currentTree: 0,
            color: '#8B4513',
            jumpingToTree: false,
            targetTree: null,
            invincible: false,
            invincibleTimer: 0,
            animationFrame: 0,
            autoMoving: true,  // ìë™ ì´ë™ í™œì„±í™”
            targetX: 100,  // ëª©í‘œ X ìœ„ì¹˜
            // ì í”„ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•œ ë³€ìˆ˜ë“¤
            jumpStartX: 0,
            jumpStartY: 0,
            jumpTargetX: 0,
            jumpTargetY: 0,
            jumpProgress: 0,
            jumpDuration: 60,  // ì í”„ì— ê±¸ë¦¬ëŠ” í”„ë ˆì„ ìˆ˜ (1ì´ˆ)
            jumpHeight: 80     // ì í”„ ìµœëŒ€ ë†’ì´
        };
        
        // ë‚˜ë¬´ ë°°ì—´ (ë¬´í•œ ìƒì„±)
        const trees = [
            { x: 50, y: 400, width: 60, height: 200, onFire: false, fireLevel: 0, id: 0, arrivalTime: null, fireStartTime: null, falling: false, fallAngle: 0, fallSpeed: 0 }
        ];
        
        // ë¬´ì  ì•„ì´í…œ ë°°ì—´
        const invincibilityItems = [];
        
        // íŒŒí‹°í´ ë°°ì—´
        const particles = [];
        
        // ë¶ˆ íŒŒí‹°í´ ë°°ì—´
        const fireParticles = [];
        
        // ì—°ê¸° íŒŒí‹°í´ ë°°ì—´
        const smokeParticles = [];
        
        // ë°”ë‚˜ë‚˜ ë°°ì—´
        const bananas = [];
        
        // í‚¤ë³´ë“œ ì…ë ¥
        const keys = {};
        
        // ë¯¸ë‹ˆê²Œì„ í‚¤ ë°°ì—´
        const miniGameKeys = ['A', 'S', 'D', 'W', 'Q', 'E', 'R', 'F', 'G', 'H', 'J', 'K', 'L', 'Z', 'X', 'C', 'V', 'B', 'N', 'M'];
        
        // ìƒ‰ê¹” ë°°ì—´
        const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
        
        // íƒ€ì´í•‘ ê²Œì„ ë‹¨ì–´ë“¤
        const typingWords = ['BANANA', 'JUMP', 'TREE', 'FIRE', 'MONKEY', 'ESCAPE', 'FAST', 'QUICK', 'RUN', 'SAFE'];
        
        // ë¯¸ë‹ˆê²Œì„ íƒ€ì…ë“¤
        const miniGameTypes = [
            'keyPress',      // í‚¤ ëˆ„ë¥´ê¸°
            'mathPuzzle',    // ìˆ˜í•™ í¼ì¦
            'colorMatch',    // ìƒ‰ê¹” ë§ì¶”ê¸°
            'typingGame',    // íƒ€ì´í•‘ ê²Œì„
            'numberOrder'    // ìˆ«ì ìˆœì„œ
        ];
        
        // ì‚¬ìš´ë“œ íš¨ê³¼ (Web Audio API ì‚¬ìš©)
        let audioContext;
        let sounds = {};
        
        // ì‚¬ìš´ë“œ ì´ˆê¸°í™”
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                createSounds();
            } catch (e) {
                console.log('Web Audio API not supported');
            }
        }
        
        // ì‚¬ìš´ë“œ ìƒì„±
        function createSounds() {
            // ì í”„ ì‚¬ìš´ë“œ
            sounds.jump = createTone(400, 0.1, 'sine');
            // ë¬´ì  ì•„ì´í…œ ìˆ˜ì§‘ ì‚¬ìš´ë“œ
            sounds.collect = createTone(800, 0.2, 'square');
            // ë¯¸ë‹ˆê²Œì„ ì„±ê³µ ì‚¬ìš´ë“œ
            sounds.success = createTone(600, 0.3, 'triangle');
            // ë¯¸ë‹ˆê²Œì„ ì‹¤íŒ¨ ì‚¬ìš´ë“œ
            sounds.fail = createTone(200, 0.5, 'sawtooth');
            // ë¶ˆ ì‚¬ìš´ë“œ
            sounds.fire = createTone(150, 0.1, 'noise');
        }
        
        // í†¤ ìƒì„±
        function createTone(frequency, duration, type) {
            return function() {
                if (!gameState.soundEnabled || !audioContext) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            };
        }
        
        // ê²Œì„ ì‹œì‘
        function startGame(difficulty) {
            gameState.difficulty = difficulty;
            gameState.running = true;
            gameState.timeLeft = Infinity; // ë¬´í•œ ì‹œê°„ (ì‹œê°„ ì œí•œ ì—†ìŒ)
            gameState.health = 100;
            gameState.score = 0;
            gameState.treeCount = 1;
            gameState.level = 1;
            gameState.combo = 0;
            gameState.bananasCollected = 0;
            gameState.cameraX = 0;  // ì¹´ë©”ë¼ ì´ˆê¸°í™”
            gameState.nextTreeReady = false; // ê²Œì„ ì‹œì‘ ì‹œ ìë™ ì´ë™ ì¤€ë¹„ ìƒíƒœ ì´ˆê¸°í™”
            gameState.fireSpreadTime = 0;  // ì‚°ë¶ˆ ë²ˆì§ ì‹œê°„ ì´ˆê¸°í™”
            gameState.invincibilityAvailable = false; // ë¬´ì  ì•„ì´í…œ ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€
            
            // ë°°ì—´ ì´ˆê¸°í™”
            bananas.length = 0;
            invincibilityItems.length = 0;
            particles.length = 0;
            fireParticles.length = 0;
            smokeParticles.length = 0;
            
            // ì›ìˆ­ì´ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (ì²« ë²ˆì§¸ ë‚˜ë¬´ ìœ„ì—ì„œ ì‹œì‘)
            monkey.x = trees[0].x + trees[0].width/2 - monkey.width/2;  // ì²« ë²ˆì§¸ ë‚˜ë¬´ ìœ„
            monkey.y = trees[0].y - monkey.height;  // ì²« ë²ˆì§¸ ë‚˜ë¬´ ìœ„
            monkey.onTree = true;
            monkey.currentTree = 0;
            monkey.autoMoving = true;
            monkey.jumpingToTree = false;
            monkey.targetTree = null;
            
            // ì²« ë²ˆì§¸ ë‚˜ë¬´ì— ë„ì°©í•œ ì‹œê°„ ê¸°ë¡
            trees[0].arrivalTime = 0;
            trees[0].fireStartTime = 1; // 1ì´ˆ í›„ì— ë¶ˆë¶™ê¸° ì‹œì‘
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('highScore').textContent = gameState.highScore;
            
            initAudio();
            gameLoop();
        }
        
        // ë°°ê²½ ê·¸ë¦¬ê¸° (ìŠ¤í¬ë¡¤ë§)
        function drawBackground() {
            // í•˜ëŠ˜ ê·¸ë¼ë°ì´ì…˜
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#90EE90');
            gradient.addColorStop(1, '#8B4513');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // êµ¬ë¦„ (ìŠ¤í¬ë¡¤ë§)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            for (let i = 0; i < 5; i++) {
                const cloudX = ((i * 200) - gameState.cameraX * 0.5) % (canvas.width + 200);
                ctx.beginPath();
                ctx.arc(cloudX, 50 + i * 20, 30, 0, Math.PI * 2);
                ctx.arc(cloudX + 25, 50 + i * 20, 25, 0, Math.PI * 2);
                ctx.arc(cloudX + 50, 50 + i * 20, 30, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            // ESC í‚¤ë¡œ ì¼ì‹œì •ì§€ë§Œ í—ˆìš©
            if (e.key === 'Escape' && gameState.running) {
                gameState.paused = !gameState.paused;
                if (gameState.paused) {
                    document.getElementById('startScreen').style.display = 'flex';
                    document.getElementById('startContent').innerHTML = '<h2>ì¼ì‹œì •ì§€</h2><button onclick="resumeGame()">ê³„ì†í•˜ê¸°</button>';
                }
            }
            
            // ë¯¸ë‹ˆê²Œì„ ì¤‘ í‚¤ ì…ë ¥ ì²˜ë¦¬ë§Œ í—ˆìš©
            if (gameState.miniGameActive) {
                handleMiniGameInput(e.key);
            }
        });
        
        // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ ë°©ì§€ (ë²„íŠ¼ í´ë¦­ë§Œ í—ˆìš©)
        document.addEventListener('touchstart', (e) => {
            // ë²„íŠ¼ì´ë‚˜ í´ë¦­ ê°€ëŠ¥í•œ ìš”ì†Œê°€ ì•„ë‹Œ ê²½ìš° í„°ì¹˜ ì´ë²¤íŠ¸ ë°©ì§€
            if (!e.target.matches('button, input, select, textarea')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // ëª¨ë°”ì¼ì—ì„œ ì¤Œ ë°©ì§€
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });
        
        document.addEventListener('gesturechange', (e) => {
            e.preventDefault();
        });
        
        document.addEventListener('gestureend', (e) => {
            e.preventDefault();
        });
        
        // í‚¤ë³´ë“œ ì…ë ¥ì€ ë¯¸ë‹ˆê²Œì„ì—ì„œë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ keyup ì´ë²¤íŠ¸ ì œê±°
        
        // ê²Œì„ ì¬ê°œ
        function resumeGame() {
            gameState.paused = false;
            document.getElementById('startScreen').style.display = 'none';
        }
        
        // ë°”ë‚˜ë‚˜ ìƒì„± í•¨ìˆ˜
        function createBanana() {
            return {
                x: Math.random() * (canvas.width - 30) + gameState.cameraX,
                y: Math.random() * (canvas.height - 200) + 100, // í•˜ëŠ˜ê³¼ ë‚˜ë¬´ ì‚¬ì´
                width: 20,
                height: 15,
                color: '#FFFF00',
                collected: false,
                animation: 0,
                bounce: 0
            };
        }
        
        // ë‚˜ë¬´ ì“°ëŸ¬ì§€ê¸° í•¨ìˆ˜
        function makeTreeFall(treeIndex) {
            if (treeIndex >= 0 && treeIndex < trees.length && !trees[treeIndex].falling) {
                trees[treeIndex].falling = true;
                trees[treeIndex].fallSpeed = 2; // ì“°ëŸ¬ì§€ëŠ” ì†ë„
                console.log(`ğŸŒ³ ë‚˜ë¬´ ${treeIndex}ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!`);
            }
        }
        
        // ìƒˆ ë‚˜ë¬´ ìƒì„± í•¨ìˆ˜
        function createNewTree() {
            const lastTree = trees[trees.length - 1];
            const newX = lastTree.x + 150 + Math.random() * 50;
            
            // ë‚˜ë¬´ ë†’ì´ì— ë” í° ì°¨ì´ë¥¼ ì£¼ê³ , ë°”ë‹¥ì— ë‹¿ë„ë¡ ì¡°ì •
            const baseHeight = 100; // ê¸°ë³¸ ë†’ì´
            const randomVariation = (Math.random() - 0.5) * 60; // ë” í° ëœë¤ ë³€ë™ (30ì”© ìœ„ì•„ë˜)
            const newHeight = Math.max(80, Math.min(160, baseHeight + randomVariation)); // ë†’ì´ ë²”ìœ„ í™•ëŒ€
            
            // ë‚˜ë¬´ê°€ ë°”ë‹¥ì— ë‹¿ë„ë¡ y ìœ„ì¹˜ ì¡°ì • (canvas.height - newHeight - 10)
            const newY = canvas.height - newHeight - 10;
            
            return {
                x: newX,
                y: newY,
                width: 60,
                height: newHeight,
                onFire: false,
                fireLevel: 0,
                id: trees.length,
                arrivalTime: null,  // ì›ìˆ­ì´ê°€ ë„ì°©í•œ ì‹œê°„
                fireStartTime: null,  // ë¶ˆì´ ë¶™ê¸° ì‹œì‘í•  ì‹œê°„
                falling: false,      // ì“°ëŸ¬ì§€ëŠ” ìƒíƒœ
                fallAngle: 0,        // ì“°ëŸ¬ì§€ëŠ” ê°ë„
                fallSpeed: 0         // ì“°ëŸ¬ì§€ëŠ” ì†ë„
            };
        }
        

        
        // íŒŒí‹°í´ ìƒì„±
        function createParticle(x, y, color, type = 'normal') {
            return {
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color,
                type: type
            };
        }
        
        // ë¯¸ë‹ˆê²Œì„ ì‹œì‘
        function startMiniGame() {
            gameState.miniGameActive = true;
            // ë‚œì´ë„ì— ë”°ë¼ ë¯¸ë‹ˆê²Œì„ íƒ€ì´ë¨¸ ì„¤ì •
            gameState.miniGameTimer = gameState.difficulty === 'easy' ? 5.0 : gameState.difficulty === 'normal' ? 3.0 : 2.0;
            gameState.miniGameType = miniGameTypes[Math.floor(Math.random() * miniGameTypes.length)];
            gameState.miniGameSuccess = false;
            
            // ë¯¸ë‹ˆê²Œì„ UI í‘œì‹œ
            document.getElementById('miniGameOverlay').style.display = 'block';
            setupMiniGame();
            
            // ë¯¸ë‹ˆê²Œì„ íƒ€ì´ë¨¸ ì‹œì‘
            miniGameTimer = setInterval(() => {
                gameState.miniGameTimer -= 0.1;
                document.getElementById('miniGameTimer').textContent = gameState.miniGameTimer.toFixed(1) + 'ì´ˆ';
                
                if (gameState.miniGameTimer <= 0) {
                    miniGameFail();
                }
            }, 100);
        }
        
        // ëª¨ë°”ì¼ ê¸°ê¸° ê°ì§€
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   (window.innerWidth <= 768 && window.innerHeight <= 1024);
        }
        
        // ë¯¸ë‹ˆê²Œì„ ì„¤ì •
        function setupMiniGame() {
            const content = document.getElementById('miniGameContent');
            const title = document.getElementById('miniGameTitle');
            const instruction = document.getElementById('miniGameInstruction');
            
            switch(gameState.miniGameType) {
                case 'keyPress':
                    const key = miniGameKeys[Math.floor(Math.random() * miniGameKeys.length)];
                    gameState.miniGameKey = key;
                    title.textContent = 'ğŸ¯ í‚¤ ëˆ„ë¥´ê¸° ë„ì „!';
                    instruction.textContent = 'ì•„ë˜ í‚¤ë¥¼ ë¹ ë¥´ê²Œ ëˆ„ë¥´ì„¸ìš”!';
                    content.innerHTML = `<div id="miniGameKey">${key}</div>`;
                    break;
                    
                case 'mathPuzzle':
                    const num1 = Math.floor(Math.random() * 10) + 1;
                    const num2 = Math.floor(Math.random() * 10) + 1;
                    const answer = num1 + num2;
                    gameState.miniGameAnswer = answer;
                    gameState.mathInput = '';
                    title.textContent = 'ğŸ§® ìˆ˜í•™ í¼ì¦!';
                    
                    if (isMobile()) {
                        // ëª¨ë°”ì¼: ê°€ìƒ ìˆ«ì íŒ¨ë“œ í‘œì‹œ
                        instruction.textContent = 'ì •ë‹µì„ ì…ë ¥í•˜ì„¸ìš”!';
                        content.innerHTML = `<div style="font-size: 48px; margin: 20px;">${num1} + ${num2} = ?</div>
                                           <div style="font-size: 24px; margin: 10px;">ì…ë ¥: <span id="mathInputText" style="color: #87CEEB;">${gameState.mathInput}</span></div>
                                           <div id="numberPad" style="margin: 20px;"></div>
                                           <div style="margin: 10px;">
                                               <button onclick="clearMathInput()" style="padding: 10px 20px; margin: 5px; background: #FF6B6B; color: white; border: none; border-radius: 10px; font-size: 18px;">ì§€ìš°ê¸°</button>
                                               <button onclick="submitMathAnswer()" style="padding: 10px 20px; margin: 5px; background: #4CAF50; color: white; border: none; border-radius: 10px; font-size: 18px;">í™•ì¸</button>
                                           </div>`;
                        
                        // ìˆ«ì íŒ¨ë“œ ìƒì„±
                        const numberPad = document.getElementById('numberPad');
                        for (let i = 0; i <= 9; i++) {
                            const btn = document.createElement('button');
                            btn.style.cssText = `width: 60px; height: 60px; margin: 5px; border: none; border-radius: 10px; background: #4CAF50; color: white; font-size: 24px; cursor: pointer;`;
                            btn.textContent = i;
                            btn.onclick = () => addMathDigit(i);
                            numberPad.appendChild(btn);
                        }
                    } else {
                        // PC: í‚¤ë³´ë“œ ì…ë ¥ ì•ˆë‚´
                        instruction.textContent = 'í‚¤ë³´ë“œë¡œ ì •ë‹µì„ ì…ë ¥í•˜ì„¸ìš”! (Enterë¡œ í™•ì¸)';
                        content.innerHTML = `<div style="font-size: 48px; margin: 20px;">${num1} + ${num2} = ?</div>
                                           <div style="font-size: 24px; margin: 10px;">ì…ë ¥: <span id="mathInputText" style="color: #87CEEB;">${gameState.mathInput}</span></div>
                                           <div style="font-size: 18px; margin: 20px; color: #FFD700;">í‚¤ë³´ë“œë¡œ ìˆ«ìë¥¼ ì…ë ¥í•˜ê³  Enterë¥¼ ëˆ„ë¥´ì„¸ìš”!</div>`;
                    }
                    break;
                    
                case 'colorMatch':
                    const targetColor = colors[Math.floor(Math.random() * colors.length)];
                    gameState.miniGameColor = targetColor;
                    title.textContent = 'ğŸ¨ ìƒ‰ê¹” ë§ì¶”ê¸°!';
                    instruction.textContent = 'ì§€ì‹œëœ ìƒ‰ê¹”ì„ í´ë¦­í•˜ì„¸ìš”!';
                    content.innerHTML = `<div style="font-size: 24px; margin: 20px;">ìƒ‰ê¹”: <span style="color: ${targetColor};">${targetColor}</span></div>
                                       <div id="colorButtons"></div>`;
                    
                    const colorButtons = document.getElementById('colorButtons');
                    const shuffledColors = [...colors].sort(() => Math.random() - 0.5);
                    shuffledColors.forEach(color => {
                        const btn = document.createElement('button');
                        btn.style.cssText = `width: 60px; height: 60px; background: ${color}; margin: 5px; border: none; border-radius: 10px; cursor: pointer;`;
                        btn.onclick = () => checkColorMatch(color);
                        colorButtons.appendChild(btn);
                    });
                    break;
                    
                case 'typingGame':
                    const word = typingWords[Math.floor(Math.random() * typingWords.length)];
                    gameState.miniGameWord = word;
                    gameState.typedWord = '';
                    title.textContent = 'âŒ¨ï¸ íƒ€ì´í•‘ ê²Œì„!';
                    
                    if (isMobile()) {
                        // ëª¨ë°”ì¼: ê°€ìƒ ì•ŒíŒŒë²³ íŒ¨ë“œ í‘œì‹œ
                        instruction.textContent = 'ë‹¨ì–´ë¥¼ ë¹ ë¥´ê²Œ íƒ€ì´í•‘í•˜ì„¸ìš”!';
                        content.innerHTML = `<div style="font-size: 36px; margin: 20px; color: #FFD700;">${word}</div>
                                           <div style="font-size: 24px; margin: 10px;">ì…ë ¥: <span id="typedText" style="color: #87CEEB;">${gameState.typedWord}</span></div>
                                           <div id="letterPad" style="margin: 20px;"></div>
                                           <div style="margin: 10px;">
                                               <button onclick="clearTypingInput()" style="padding: 10px 20px; margin: 5px; background: #FF6B6B; color: white; border: none; border-radius: 10px; font-size: 18px;">ì§€ìš°ê¸°</button>
                                           </div>`;
                        
                        // ì•ŒíŒŒë²³ íŒ¨ë“œ ìƒì„±
                        const letterPad = document.getElementById('letterPad');
                        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                        for (let i = 0; i < alphabet.length; i++) {
                            const btn = document.createElement('button');
                            btn.style.cssText = `width: 40px; height: 40px; margin: 3px; border: none; border-radius: 8px; background: #4CAF50; color: white; font-size: 16px; cursor: pointer;`;
                            btn.textContent = alphabet[i];
                            btn.onclick = () => addTypingLetter(alphabet[i]);
                            letterPad.appendChild(btn);
                        }
                    } else {
                        // PC: í‚¤ë³´ë“œ ì…ë ¥ ì•ˆë‚´
                        instruction.textContent = 'í‚¤ë³´ë“œë¡œ ë‹¨ì–´ë¥¼ íƒ€ì´í•‘í•˜ì„¸ìš”!';
                        content.innerHTML = `<div style="font-size: 36px; margin: 20px; color: #FFD700;">${word}</div>
                                           <div style="font-size: 24px; margin: 10px;">ì…ë ¥: <span id="typedText" style="color: #87CEEB;">${gameState.typedWord}</span></div>
                                           <div style="font-size: 18px; margin: 20px; color: #FFD700;">í‚¤ë³´ë“œë¡œ ë‹¨ì–´ë¥¼ íƒ€ì´í•‘í•˜ì„¸ìš”! (Backspaceë¡œ ì§€ìš°ê¸°)</div>`;
                    }
                    break;
                    
                case 'numberOrder':
                    const numbers = [];
                    for (let i = 1; i <= 5; i++) {
                        numbers.push(i);
                    }
                    // ìˆ«ìë¥¼ ëœë¤í•˜ê²Œ ì„ê¸°
                    const shuffledNumbers = [...numbers].sort(() => Math.random() - 0.5);
                    gameState.miniGameNumbers = shuffledNumbers;
                    gameState.currentNumberIndex = 0;
                    title.textContent = 'ğŸ”¢ ìˆ«ì ìˆœì„œ!';
                    instruction.textContent = '1ë¶€í„° 5ê¹Œì§€ ìˆœì„œëŒ€ë¡œ í´ë¦­í•˜ì„¸ìš”!';
                    content.innerHTML = `<div id="numberButtons" style="margin: 20px;"></div>`;
                    
                    const numberButtons = document.getElementById('numberButtons');
                    shuffledNumbers.forEach((num, index) => {
                        const btn = document.createElement('button');
                        btn.style.cssText = `width: 60px; height: 60px; margin: 5px; border: none; border-radius: 10px; background: #4CAF50; color: white; font-size: 24px; cursor: pointer;`;
                        btn.textContent = num;
                        btn.onclick = () => checkNumberOrder(num);
                        numberButtons.appendChild(btn);
                    });
                    break;
            }
        }
        
        // ëª¨ë°”ì¼ìš© ìˆ˜í•™ ì…ë ¥ í•¨ìˆ˜ë“¤
        function addMathDigit(digit) {
            gameState.mathInput += digit;
            const mathInputText = document.getElementById('mathInputText');
            if (mathInputText) {
                mathInputText.textContent = gameState.mathInput;
            }
            
            // ì •ë‹µ ì²´í¬
            if (parseInt(gameState.mathInput) === gameState.miniGameAnswer) {
                miniGameSuccess();
            }
        }
        
        function clearMathInput() {
            gameState.mathInput = '';
            const mathInputText = document.getElementById('mathInputText');
            if (mathInputText) {
                mathInputText.textContent = gameState.mathInput;
            }
        }
        
        function submitMathAnswer() {
            if (parseInt(gameState.mathInput) === gameState.miniGameAnswer) {
                miniGameSuccess();
            } else {
                miniGameFail();
            }
        }
        
        // ëª¨ë°”ì¼ìš© íƒ€ì´í•‘ ì…ë ¥ í•¨ìˆ˜ë“¤
        function addTypingLetter(letter) {
            gameState.typedWord += letter;
            const typedText = document.getElementById('typedText');
            if (typedText) {
                typedText.textContent = gameState.typedWord;
            }
            
            // ë‹¨ì–´ ì™„ì„± ì²´í¬
            if (gameState.typedWord === gameState.miniGameWord) {
                miniGameSuccess();
            }
        }
        
        function clearTypingInput() {
            gameState.typedWord = '';
            const typedText = document.getElementById('typedText');
            if (typedText) {
                typedText.textContent = gameState.typedWord;
            }
        }
        
        // ë¯¸ë‹ˆê²Œì„ ì…ë ¥ ì²˜ë¦¬ (í‚¤ë³´ë“œìš©)
        function handleMiniGameInput(key) {
            switch(gameState.miniGameType) {
                case 'keyPress':
                    if (key.toUpperCase() === gameState.miniGameKey) {
                        miniGameSuccess();
                    }
                    break;
                    
                case 'mathPuzzle':
                    if (key >= '0' && key <= '9') {
                        addMathDigit(key);
                    } else if (key === 'Backspace') {
                        clearMathInput();
                    } else if (key === 'Enter') {
                        submitMathAnswer();
                    }
                    break;
                    
                case 'typingGame':
                    if (key.length === 1) {  // í•œ ê¸€ìë§Œ ì…ë ¥
                        addTypingLetter(key.toUpperCase());
                    } else if (key === 'Backspace') {
                        clearTypingInput();
                    }
                    break;
            }
        }
        
        // ìƒ‰ê¹” ë§ì¶”ê¸° ì²´í¬
        function checkColorMatch(color) {
            if (color === gameState.miniGameColor) {
                miniGameSuccess();
            } else {
                miniGameFail();
            }
        }
        
        // ìˆ«ì ìˆœì„œ ì²´í¬
        function checkNumberOrder(clickedNumber) {
            const expectedNumber = gameState.currentNumberIndex + 1;
            if (clickedNumber === expectedNumber) {
                gameState.currentNumberIndex++;
                
                // ëª¨ë“  ìˆ«ìë¥¼ ìˆœì„œëŒ€ë¡œ í´ë¦­í–ˆëŠ”ì§€ ì²´í¬
                if (gameState.currentNumberIndex >= 5) {
                    miniGameSuccess();
                }
            } else {
                miniGameFail();
            }
        }
        
        // ë¯¸ë‹ˆê²Œì„ ì„±ê³µ
        function miniGameSuccess() {
            gameState.miniGameActive = false;
            gameState.miniGameSuccess = true;
            clearInterval(miniGameTimer);
            
            if (sounds.success) sounds.success();
            
            document.getElementById('miniGameOverlay').style.display = 'none';
            
            // ì í”„ ì• ë‹ˆë©”ì´ì…˜ì´ ì´ë¯¸ ì‹œì‘ë˜ì—ˆìœ¼ë¯€ë¡œ ì¶”ê°€ ì‘ì—… ë¶ˆí•„ìš”
            // ì›ìˆ­ì´ëŠ” ìë™ìœ¼ë¡œ ì í”„ ì• ë‹ˆë©”ì´ì…˜ì„ í†µí•´ ë‹¤ìŒ ë‚˜ë¬´ë¡œ ì´ë™í•¨
        }
        
        // ë¯¸ë‹ˆê²Œì„ ì‹¤íŒ¨
        function miniGameFail() {
            gameState.miniGameActive = false;
            clearInterval(miniGameTimer);
            
            if (sounds.fail) sounds.fail();
            
            document.getElementById('miniGameOverlay').style.display = 'none';
            gameState.combo = 0;
            
            // ë¬´ì  ì•„ì´í…œì´ ìˆìœ¼ë©´ ì‚¬ìš©í•˜ê³  ìë™ìœ¼ë¡œ ë‹¤ìŒ ë‚˜ë¬´ë¡œ ì´ë™
            if (gameState.invincibilityAvailable) {
                gameState.invincibilityAvailable = false;
                console.log("ğŸ›¡ï¸ ë¬´ì  ì•„ì´í…œ ì‚¬ìš©! ìë™ìœ¼ë¡œ ë‹¤ìŒ ë‚˜ë¬´ë¡œ ì´ë™í•©ë‹ˆë‹¤.");
                
                // ë‹¤ìŒ ë‚˜ë¬´ë¡œ ìë™ ì´ë™
                const nextTreeIndex = monkey.currentTree + 1;
                if (nextTreeIndex < trees.length) {
                    const nextTree = trees[nextTreeIndex];
                    monkey.jumpingToTree = true;
                    monkey.targetTree = nextTree;
                    monkey.jumpStartX = monkey.x;
                    monkey.jumpStartY = monkey.y;
                    monkey.jumpTargetX = nextTree.x + nextTree.width/2 - monkey.width/2;
                    monkey.jumpTargetY = nextTree.y - monkey.height;
                    monkey.jumpProgress = 0;
                    monkey.jumpDuration = 60;
                    monkey.jumpHeight = 80;
                    
                    // 3ë²ˆ ë‚˜ë¬´ë¶€í„° í™”ë©´ ìŠ¤í¬ë¡¤ ì‹œì‘
                    if (gameState.treeCount >= 3) {
                        gameState.cameraX = nextTree.x - canvas.width/2;
                    }
                    gameState.treeCount++;
                }
            } else {
                // ê²Œì„ ì˜¤ë²„
                gameState.gameOver = true;
                gameState.running = false;
            }
        }
        
        // íŒŒí‹°í´ íš¨ê³¼ ìƒì„±
        function createParticleEffect(x, y, color, type) {
            for (let i = 0; i < 10; i++) {
                particles.push(createParticle(x, y, color, type));
            }
        }
        
        // ë¬´ì  ì•„ì´í…œ ìƒì„± í•¨ìˆ˜
        function createInvincibilityItem() {
            const treeIndex = Math.floor(Math.random() * trees.length);
            const tree = trees[treeIndex];
            return {
                x: tree.x + tree.width/2 - 15,
                y: tree.y - 50, // ë‚˜ë¬´ ìœ„ë¡œ ì´ë™
                width: 30,
                height: 30,
                collected: false,
                animation: 0,
                treeId: tree.id
            };
        }
        
        // ì›ìˆ­ì´ ê·¸ë¦¬ê¸° (ì• ë‹ˆë©”ì´ì…˜ í¬í•¨)
        function drawMonkey() {
            monkey.animationFrame += 0.1;
            
            // ë¬´ì  ìƒíƒœì¼ ë•Œ ê¹œë¹¡ì„ íš¨ê³¼
            if (monkey.invincible) {
                if (Math.floor(monkey.animationFrame * 10) % 2 === 0) return;
            }
            
            // ì¹´ë©”ë¼ ìŠ¤í¬ë¡¤ ì ìš©ëœ ì›ìˆ­ì´ ìœ„ì¹˜
            const drawX = monkey.x - gameState.cameraX;
            const drawY = monkey.y;
            
            // í™”ë©´ ë°–ì˜ ì›ìˆ­ì´ëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ
            if (drawX + monkey.width < 0 || drawX > canvas.width) return;
            
            // ì í”„ ì¤‘ì¼ ë•Œ íšŒì „ íš¨ê³¼
            if (monkey.jumpingToTree) {
                const progress = monkey.jumpProgress / monkey.jumpDuration;
                const rotation = progress * 360; // ì í”„ ì¤‘ 360ë„ íšŒì „
                
                ctx.save();
                ctx.translate(drawX + monkey.width/2, drawY + monkey.height/2);
                ctx.rotate(rotation * Math.PI / 180);
                ctx.translate(-(drawX + monkey.width/2), -(drawY + monkey.height/2));
            }
            
            // ëª¸ì²´
            ctx.fillStyle = monkey.color;
            ctx.fillRect(drawX, drawY, monkey.width, monkey.height);
            
            // ì–¼êµ´
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(drawX + 20, drawY + 15, 12, 0, Math.PI * 2);
            ctx.fill();
            
                              // ê·€
                  ctx.fillStyle = '#8B4513';
                  ctx.beginPath();
                  ctx.ellipse(drawX + 8, drawY + 8, 6, 8, 0, 0, Math.PI * 2);
                  ctx.ellipse(drawX + 32, drawY + 8, 6, 8, 0, 0, Math.PI * 2);
                  ctx.fill();
                  
                  // ê·€ ì•ˆìª½
                  ctx.fillStyle = '#FFB6C1';
                  ctx.beginPath();
                  ctx.ellipse(drawX + 8, drawY + 8, 3, 4, 0, 0, Math.PI * 2);
                  ctx.ellipse(drawX + 32, drawY + 8, 3, 4, 0, 0, Math.PI * 2);
                  ctx.fill();
                  
                  // ëˆˆ
                  ctx.fillStyle = 'black';
                  ctx.beginPath();
                  ctx.arc(drawX + 17, drawY + 12, 2, 0, Math.PI * 2);
                  ctx.arc(drawX + 23, drawY + 12, 2, 0, Math.PI * 2);
                  ctx.fill();
            
            // ì… (ì• ë‹ˆë©”ì´ì…˜)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const mouthY = drawY + 18 + Math.sin(monkey.animationFrame) * 2;
            ctx.arc(drawX + 20, mouthY, 3, 0, Math.PI);
            ctx.stroke();
            
            // ì í”„ ì¤‘ì¼ ë•Œ íšŒì „ íš¨ê³¼ ë³µì›
            if (monkey.jumpingToTree) {
                ctx.restore();
                
                // ì í”„ ê¶¤ì  íš¨ê³¼ (ì›ìˆ­ì´ì˜ ì‹¤ì œ ì í”„ ê²½ë¡œë¥¼ ë”°ë¼ê°)
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                
                // í¬ë¬¼ì„  ê¶¤ì  ê·¸ë¦¬ê¸°
                const startDrawX = monkey.jumpStartX - gameState.cameraX;
                const targetDrawX = monkey.jumpTargetX - gameState.cameraX;
                const startY = monkey.jumpStartY + monkey.height/2;
                const targetY = monkey.jumpTargetY + monkey.height/2;
                
                ctx.moveTo(startDrawX + monkey.width/2, startY);
                
                // í¬ë¬¼ì„ ì„ ì—¬ëŸ¬ ì ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ê·¸ë¦¬ê¸°
                for (let i = 1; i <= 20; i++) {
                    const t = i / 20;
                    const x = startDrawX + monkey.width/2 + (targetDrawX - startDrawX) * t;
                    const y = startY + (targetY - startY) * t - monkey.jumpHeight * Math.sin(Math.PI * t);
                    ctx.lineTo(x, y);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // ë°”ë‚˜ë‚˜ ê·¸ë¦¬ê¸°
        function drawBananas() {
            bananas.forEach(banana => {
                if (!banana.collected) {
                    // ë°”ë‚˜ë‚˜ ì• ë‹ˆë©”ì´ì…˜ (ë– ë‹¤ë‹ˆëŠ” íš¨ê³¼)
                    banana.animation += 0.1;
                    const bounce = Math.sin(banana.animation) * 3;
                    
                    const drawX = banana.x - gameState.cameraX;
                    const drawY = banana.y + bounce;
                    
                    // í™”ë©´ ë°–ì˜ ë°”ë‚˜ë‚˜ëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ
                    if (drawX + banana.width < 0 || drawX > canvas.width) {
                        return;
                    }
                    
                    // ë°”ë‚˜ë‚˜ ëª¸í†µ (ë…¸ë€ìƒ‰ ê³¡ì„  ëª¨ì–‘)
                    ctx.fillStyle = banana.color;
                    ctx.beginPath();
                    ctx.ellipse(drawX + 10, drawY + 7.5, 10, 7.5, Math.PI/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ë°”ë‚˜ë‚˜ ê»ì§ˆ (ê°ˆìƒ‰ ì )
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(drawX + 8, drawY + 6, 2, 0, Math.PI * 2);
                    ctx.arc(drawX + 12, drawY + 6, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ë°”ë‚˜ë‚˜ ë°˜ì§ì„ íš¨ê³¼
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(drawX + 7, drawY + 5, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
        
        // ë‚˜ë¬´ ê·¸ë¦¬ê¸°
        function drawTrees() {
            trees.forEach((tree, index) => {
                const drawX = tree.x - gameState.cameraX;
                
                // í™”ë©´ ë°–ì˜ ë‚˜ë¬´ëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ
                if (drawX + tree.width < 0 || drawX > canvas.width) {
                    return;
                }
                
                // ì“°ëŸ¬ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì ìš©
                if (tree.falling) {
                    tree.fallAngle += tree.fallSpeed * 0.1;
                    if (tree.fallAngle >= Math.PI / 2) {
                        tree.fallAngle = Math.PI / 2; // ì™„ì „íˆ ì“°ëŸ¬ì§
                    }
                }
                
                // íšŒì „ ë³€í™˜ ì ìš©
                ctx.save();
                ctx.translate(drawX + tree.width/2, tree.y + tree.height);
                ctx.rotate(tree.fallAngle);
                
                // ë‚˜ë¬´ ëª¸í†µ (ê°ˆìƒ‰)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-tree.width/2, -tree.height, tree.width, tree.height);
                
                // ë‚˜ë¬´ ì (ì´ˆë¡ìƒ‰)
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.arc(0, -tree.height, tree.width * 0.8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
                // ë‚˜ë­‡ê°€ì§€ ì œê±°ë¨ - ê¹”ë”í•œ ë‚˜ë¬´ ë””ìì¸
                
                // ë¶ˆì´ ë¶™ì€ ë‚˜ë¬´ ê·¸ë¦¬ê¸°
                if (tree.onFire) {
                    tree.fireLevel = Math.min(tree.fireLevel + 0.1, 10);
                    
                    const fireHeight = tree.height * 0.3;
                    const shake = Math.sin(Date.now() * 0.01) * 2;
                    const fireIntensity = Math.min(tree.fireLevel / 10, 1);
                    
                    // ë¶ˆê½ƒ íš¨ê³¼ (ë” ë‘ê»ê³  ìì—°ìŠ¤ëŸ¬ìš´ ë¶ˆê½ƒ)
                    for (let i = 0; i < 5; i++) {
                        const flameOffset = Math.sin(Date.now() * 0.01 + i * 0.5) * 8;
                        const flameHeight = fireHeight * (0.4 + i * 0.1); // ë†’ì´ë¥¼ ë‚®ì¶¤ (0.7 -> 0.4, 0.15 -> 0.1)
                        const flameWidth = 15 + i * 3; // ë¶ˆê½ƒì„ ë” ë‘ê»ê²Œ
                        
                        // ë¶ˆê½ƒ ìƒ‰ìƒ (ë…¸ë€ìƒ‰ì—ì„œ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ)
                        const flameColor = i === 0 ? `rgba(255, 255, 0, ${fireIntensity * 0.9})` :
                                          i === 1 ? `rgba(255, 200, 0, ${fireIntensity * 0.8})` :
                                          i === 2 ? `rgba(255, 150, 0, ${fireIntensity * 0.7})` :
                                          i === 3 ? `rgba(255, 100, 0, ${fireIntensity * 0.6})` :
                                          `rgba(255, 50, 0, ${fireIntensity * 0.5})`;
                        
                        ctx.fillStyle = flameColor;
                        ctx.beginPath();
                        ctx.moveTo(drawX + tree.width/2 + flameOffset, tree.y + tree.height - flameHeight);
                        ctx.quadraticCurveTo(drawX + tree.width/2 + flameOffset + flameWidth, tree.y + tree.height - flameHeight * 0.6, drawX + tree.width/2 + flameOffset, tree.y + tree.height);
                        ctx.quadraticCurveTo(drawX + tree.width/2 + flameOffset - flameWidth, tree.y + tree.height - flameHeight * 0.6, drawX + tree.width/2 + flameOffset, tree.y + tree.height - flameHeight);
                        ctx.fill();
                    }
                    
                    // ë¶ˆë˜¥ íŒŒí‹°í´ ìƒì„± (ë” ë§ì€ ë¶ˆë˜¥)
                    if (Math.random() < 0.7) {
                        for (let i = 0; i < 5; i++) {
                            fireParticles.push({
                                x: drawX + Math.random() * tree.width,
                                y: tree.y + tree.height - Math.random() * fireHeight * 0.6, // ë†’ì´ ë²”ìœ„ë¥¼ ì¤„ì„
                                vx: (Math.random() - 0.5) * 4,
                                vy: -Math.random() * 4 - 1, // ë†’ì´ë¥¼ ë‚®ì¶¤ (6 -> 4, 2 -> 1)
                                life: 1.0,
                                size: Math.random() * 4 + 2
                            });
                        }
                    }
                    
                    // ì—°ê¸° íš¨ê³¼ (ë” ë§ì€ ì—°ê¸°)
                    if (Math.random() < 0.4) {
                        for (let i = 0; i < 3; i++) {
                            smokeParticles.push({
                                x: drawX + tree.width/2 + (Math.random() - 0.5) * 30,
                                y: tree.y + tree.height - fireHeight * 0.6 + Math.random() * 10, // ë†’ì´ë¥¼ ë‚®ì¶¤
                                vx: (Math.random() - 0.5) * 1.5,
                                vy: -Math.random() * 2 - 0.5, // ë†’ì´ë¥¼ ë‚®ì¶¤ (3 -> 2, 1 -> 0.5)
                                life: 1.0,
                                size: Math.random() * 12 + 6
                            });
                        }
                    }
                }
            });
        }
        
        // ë¬´ì  ì•„ì´í…œ ê·¸ë¦¬ê¸° (ì• ë‹ˆë©”ì´ì…˜)
        function drawInvincibilityItems() {
            invincibilityItems.forEach(item => {
                if (!item.collected) {
                    item.animation += 0.1;
                    const bounce = Math.sin(item.animation) * 3;
                    const drawX = item.x - gameState.cameraX;  // ì¹´ë©”ë¼ ìŠ¤í¬ë¡¤ ì ìš©
                    
                    // í™”ë©´ ë°–ì˜ ì•„ì´í…œì€ ê·¸ë¦¬ì§€ ì•ŠìŒ
                    if (drawX + item.width < 0 || drawX > canvas.width) return;
                    
                    // ë°”ë‚˜ë‚˜ ëª¨ì–‘ ê·¸ë¦¬ê¸°
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.ellipse(drawX + 15, item.y + 15 + bounce, 12, 8, Math.PI/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ë°”ë‚˜ë‚˜ í…Œë‘ë¦¬
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // ë°”ë‚˜ë‚˜ ê»ì§ˆ íš¨ê³¼
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(drawX + 15, item.y + 15 + bounce, 8, 0, Math.PI);
                    ctx.stroke();
                }
            });
        }
        

        
        // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
        function drawParticles() {
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.02;
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                    return;
                }
                
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.fillRect(particle.x, particle.y, 4, 4);
            });
            ctx.globalAlpha = 1;
        }
        
        // ë¶ˆ íŒŒí‹°í´ ê·¸ë¦¬ê¸°
        function drawFireParticles() {
            fireParticles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.01;
                
                if (particle.life <= 0) {
                    fireParticles.splice(index, 1);
                    return;
                }
                
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = '#FF4500';
                ctx.fillRect(particle.x, particle.y, particle.size || 3, particle.size || 3);
            });
            ctx.globalAlpha = 1;
        }
        
        // ì—°ê¸° íŒŒí‹°í´ ê·¸ë¦¬ê¸°
        function drawSmokeParticles() {
            smokeParticles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.005;
                
                if (particle.life <= 0) {
                    smokeParticles.splice(index, 1);
                    return;
                }
                
                ctx.globalAlpha = particle.life * 0.7;
                ctx.fillStyle = `rgba(128, 128, 128, ${particle.life})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }
        
        // ì¶©ëŒ ê°ì§€
        function checkCollisions() {
            // ë°”ë‚˜ë‚˜ ìˆ˜ì§‘
            bananas.forEach(banana => {
                if (!banana.collected &&
                    monkey.x < banana.x + banana.width &&
                    monkey.x + monkey.width > banana.x &&
                    monkey.y < banana.y + banana.height &&
                    monkey.y + monkey.height > banana.y) {
                    banana.collected = true;
                    gameState.health += 10; // ë°”ë‚˜ë‚˜ í•˜ë‚˜ë‹¹ ì²´ë ¥ 10 ì¦ê°€
                    gameState.score += 20;
                    gameState.combo++;
                    gameState.bananasCollected++; // ë°”ë‚˜ë‚˜ ìˆ˜ì§‘ ì¹´ìš´íŠ¸ ì¦ê°€
                    
                    if (sounds.collect) sounds.collect();
                    createParticleEffect(banana.x, banana.y, '#FFFF00', 'collect');
                }
            });
            
            // ë¬´ì  ì•„ì´í…œ ìˆ˜ì§‘
            invincibilityItems.forEach(item => {
                if (!item.collected &&
                    monkey.x < item.x + item.width &&
                    monkey.x + monkey.width > item.x &&
                    monkey.y < item.y + item.height &&
                    monkey.y + monkey.height > item.y) {
                    item.collected = true;
                    gameState.invincibilityAvailable = true;
                    gameState.score += 50;
                    gameState.combo++;
                    
                    if (sounds.collect) sounds.collect();
                    createParticleEffect(item.x, item.y, '#FFD700', 'collect');
                }
            });
            
            // ë¶ˆì— ë‹¿ìœ¼ë©´ ì²´ë ¥ ê°ì†Œ
            if (!monkey.invincible) {
                trees.forEach(tree => {
                    const treeDrawX = tree.x - gameState.cameraX;  // ì¹´ë©”ë¼ ìŠ¤í¬ë¡¤ ê³ ë ¤
                    if (tree.onFire &&
                        monkey.x < treeDrawX + tree.width &&
                        monkey.x + monkey.width > treeDrawX &&
                        monkey.y < tree.y + tree.height &&
                        monkey.y + monkey.height > tree.y) {
                        gameState.health -= 0.5;
                        gameState.combo = 0;
                        
                        if (sounds.fire) sounds.fire();
                    }
                });
            }
        }
        

        
        // ì›ìˆ­ì´ ì—…ë°ì´íŠ¸
        function updateMonkey() {
            if (gameState.miniGameActive || gameState.paused) return;
            
            // ë¬´ì  íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
            if (monkey.invincible) {
                monkey.invincibleTimer -= 1/60;
                if (monkey.invincibleTimer <= 0) {
                    monkey.invincible = false;
                }
            }
            
            // ì í”„ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì¼ ë•Œ
            if (monkey.jumpingToTree) {
                monkey.jumpProgress += 1;
                const progress = monkey.jumpProgress / monkey.jumpDuration;
                
                if (progress >= 1) {
                    // ì í”„ ì™„ë£Œ
                    monkey.jumpingToTree = false;
                    monkey.onTree = true;
                    

                    
                    monkey.currentTree = monkey.targetTree.id;
                    monkey.x = monkey.targetTree.x + monkey.targetTree.width/2 - monkey.width/2;
                    monkey.y = monkey.targetTree.y - monkey.height;
                    monkey.targetTree = null;
                    monkey.jumpProgress = 0;
                    
                    // ì´ì „ ë‚˜ë¬´ ì“°ëŸ¬ëœ¨ë¦¬ê¸°
                    const previousTreeIndex = monkey.currentTree - 1;
                    if (previousTreeIndex >= 0) {
                        makeTreeFall(previousTreeIndex);
                    }
                    
                    // ë‚˜ë¬´ì— ë„ì°©í•œ ì‹œê°„ ê¸°ë¡
                    const currentTime = gameState.fireSpreadTime;
                    trees[monkey.currentTree].arrivalTime = currentTime;
                    trees[monkey.currentTree].fireStartTime = currentTime + 1; // 1ì´ˆ í›„ì— ë¶ˆë¶™ê¸° ì‹œì‘
                    
                    gameState.treeCount++;
                    gameState.score += 50 + (gameState.combo * 10);
                    gameState.combo++;
                    
                    // 3ë²ˆ ë‚˜ë¬´ë¶€í„° í™”ë©´ ìŠ¤í¬ë¡¤ ì‹œì‘
                    if (gameState.treeCount >= 3) {
                        gameState.cameraX = monkey.x - canvas.width/2;
                    }
                    
                    // ì½¤ë³´ ë³´ë„ˆìŠ¤
                    if (gameState.combo >= 5) {
                        gameState.score += 100;
                        createParticleEffect(monkey.x, monkey.y, '#FFD700', 'combo');
                    }
                } else {
                    // ì í”„ ì• ë‹ˆë©”ì´ì…˜ ê³„ì‚°
                    const easeInOut = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    // X ìœ„ì¹˜ (ì„ í˜• ë³´ê°„)
                    monkey.x = monkey.jumpStartX + (monkey.jumpTargetX - monkey.jumpStartX) * easeInOut;
                    
                    // Y ìœ„ì¹˜ (í¬ë¬¼ì„ )
                    const jumpCurve = Math.sin(progress * Math.PI);
                    monkey.y = monkey.jumpStartY + (monkey.jumpTargetY - monkey.jumpStartY) * easeInOut - monkey.jumpHeight * jumpCurve;
                }
                return;
            }
            
            // ìë™ ì´ë™ ì‹œìŠ¤í…œ - ì›ìˆ­ì´ëŠ” ë‚˜ë¬´ ìœ„ì— ê³ ì •ë˜ì–´ ìˆìŒ
            // ì‚¬ìš©ì ì…ë ¥ì€ ë¬´ì‹œí•˜ê³  ìë™ìœ¼ë¡œë§Œ ë™ì‘
            monkey.velocityX = 0;  // ì›ìˆ­ì´ëŠ” ì›€ì§ì´ì§€ ì•ŠìŒ
            
            // í˜„ì¬ ë‚˜ë¬´ê°€ ë¶ˆì— íƒ€ê³  ìˆê³ , ì¶©ë¶„íˆ íƒ€ë©´ ìë™ìœ¼ë¡œ ë‹¤ìŒ ë‚˜ë¬´ë¡œ ì´ë™
            const currentTree = trees[monkey.currentTree];
            if (currentTree && currentTree.onFire && currentTree.fireLevel > 3 && !monkey.jumpingToTree) {  // fireLevelì„ 5ì—ì„œ 3ìœ¼ë¡œ ë‚®ì¶¤
                const nextTreeIndex = monkey.currentTree + 1;
                
                if (nextTreeIndex < trees.length) {
                    const nextTree = trees[nextTreeIndex];
                    const distance = nextTree.x - currentTree.x;
                    
                    if (distance < 200 && !nextTree.onFire) {
                        // ì í”„ ì‹œì‘
                        monkey.jumpingToTree = true;
                        monkey.targetTree = nextTree;
                        monkey.jumpStartX = monkey.x;
                        monkey.jumpStartY = monkey.y;
                        monkey.jumpTargetX = nextTree.x + nextTree.width/2 - monkey.width/2;
                        monkey.jumpTargetY = nextTree.y - monkey.height;
                        monkey.jumpProgress = 0;
                        monkey.onTree = false;
                        
                        // ë¯¸ë‹ˆê²Œì„ ì‹œì‘
                        startMiniGame();
                    }
                }
            }
            
            // ì‚¬ìš©ì ì…ë ¥ì€ ì™„ì „íˆ ë¬´ì‹œ - ì›ìˆ­ì´ëŠ” ìë™ìœ¼ë¡œë§Œ ë™ì‘
            // ë‚˜ë¬´ ì˜¤ë¥´ê¸°/ë‚´ë¦¬ê¸°, ì í”„ ë“± ëª¨ë“  ìˆ˜ë™ ì¡°ì‘ ì œê±°
            
            // ì›ìˆ­ì´ëŠ” í•­ìƒ í˜„ì¬ ë‚˜ë¬´ ìœ„ì— ê³ ì • (ì í”„ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (monkey.onTree && currentTree && !monkey.jumpingToTree) {
                monkey.x = currentTree.x + currentTree.width/2 - monkey.width/2;
                monkey.y = currentTree.y - monkey.height;
            }
        }
        

        
        // ì‚°ë¶ˆ ì‹œìŠ¤í…œ
        function updateFire() {
            const currentTime = Math.floor(gameState.timeLeft);
            gameState.fireSpreadTime += 1/60;  // ì‚°ë¶ˆ ë²ˆì§ ì‹œê°„ ì¦ê°€
            
            // ì›ìˆ­ì´ê°€ ë„ì°©í•œ í›„ 1ì´ˆ í›„ì— ë¶ˆì´ ë¶™ë„ë¡ ìˆ˜ì •
            trees.forEach((tree, index) => {
                // fireStartTimeì´ ì„¤ì •ë˜ì–´ ìˆê³ , í˜„ì¬ ì‹œê°„ì´ fireStartTimeì— ë„ë‹¬í–ˆìœ¼ë©´ ë¶ˆë¶™ê¸° ì‹œì‘
                if (tree.fireStartTime !== null && gameState.fireSpreadTime >= tree.fireStartTime && !tree.onFire) {
                    tree.onFire = true;
                }
                
                // ë¶ˆ ê°•ë„ ì¦ê°€ (ì†ë„ë¥¼ ë” ëŠ¦ì¶¤)
                if (tree.onFire && tree.fireLevel < 10) {
                    tree.fireLevel += 0.02;  // 0.03ì—ì„œ 0.02ë¡œ ì¤„ì—¬ì„œ ë” ëŠë¦¬ê²Œ
                }
            });
            
            // ìƒˆ ë‚˜ë¬´ ìƒì„± (í™”ë©´ì— ë³´ì´ëŠ” ë‚˜ë¬´ê°€ 5ê°œ ë¯¸ë§Œì¼ ë•Œ)
            const visibleTrees = trees.filter(tree => {
                const drawX = tree.x - gameState.cameraX;
                return drawX < canvas.width + 100 && drawX > -100;
            });
            
            if (visibleTrees.length < 5) {
                trees.push(createNewTree());
                
                // ìƒˆ ë‚˜ë¬´ì— ë¬´ì  ì•„ì´í…œ ìƒì„± (20% í™•ë¥ )
                if (Math.random() < 0.2) {
                    invincibilityItems.push(createInvincibilityItem());
                }
            }
            
            // ë°”ë‚˜ë‚˜ ìƒì„± (3ì´ˆë§ˆë‹¤)
            if (Math.random() < 0.02) { // ì•½ 3ì´ˆë§ˆë‹¤ (60fps * 3ì´ˆ * 0.02 = 3.6ì´ˆ)
                bananas.push(createBanana());
            }
            
            // ë ˆë²¨ ì—…
            gameState.level = Math.floor(gameState.treeCount / 5) + 1;
        }
        
        // ê²Œì„ ì˜¤ë²„ ì²´í¬
        function checkGameOver() {
            // ì²´ë ¥ì´ 0ì´ ë˜ë©´ ê²Œì„ ì˜¤ë²„
            if (gameState.health <= 0) {
                gameState.gameOver = true;
                gameState.running = false;
            }
            
            // í˜„ì¬ ë‚˜ë¬´ê°€ ë¶ˆì— íƒ€ê³  ìˆê³ , ì¶©ë¶„íˆ íƒ€ë©´ ê²Œì„ ì˜¤ë²„
            if (monkey.onTree && trees[monkey.currentTree]) {
                const currentTree = trees[monkey.currentTree];
                const treeScreenX = currentTree.x - gameState.cameraX;
                
                // ë‚˜ë¬´ê°€ í™”ë©´ì— ì™„ì „íˆ ë³´ì´ê³  ì™„ì „íˆ íƒ€ë©´ ê²Œì„ ì˜¤ë²„
                if (treeScreenX >= 0 && treeScreenX + currentTree.width <= canvas.width && currentTree.fireLevel >= 10) {
                    gameState.gameOver = true;
                    gameState.running = false;
                }
            }
            
            // ë°”ë‹¥ì— ë‹¿ìœ¼ë©´ ê²Œì„ ì˜¤ë²„ (ì´ë¯¸ updateMonkeyì—ì„œ ì²˜ë¦¬ë¨)
        }
        
        // UI ì—…ë°ì´íŠ¸
        function updateUI() {
            document.getElementById('health').textContent = Math.max(0, Math.floor(gameState.health));
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('treeCount').textContent = gameState.treeCount;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('combo').textContent = gameState.combo;
            document.getElementById('bananaCount').textContent = gameState.bananasCollected;
            
            // ë¬´ì  ì•„ì´í…œ ìƒíƒœ í‘œì‹œ
            const invincibilityStatus = document.getElementById('invincibilityStatus');
            if (invincibilityStatus) {
                if (gameState.invincibilityAvailable) {
                    invincibilityStatus.textContent = 'ğŸ›¡ï¸ ë¬´ì  ì•„ì´í…œ ë³´ìœ ';
                    invincibilityStatus.style.color = '#FFD700';
                } else {
                    invincibilityStatus.textContent = 'ë¬´ì  ì•„ì´í…œ ì—†ìŒ';
                    invincibilityStatus.style.color = '#666';
                }
            }
        }
        
        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            if (!gameState.running || gameState.paused) {
                if (gameState.gameOver) {
                    // ìµœê³  ì ìˆ˜ ì—…ë°ì´íŠ¸
                    if (gameState.score > gameState.highScore) {
                        gameState.highScore = gameState.score;
                        localStorage.setItem('monkeyHighScore', gameState.highScore);
                    }
                    
                    // ê²Œì„ ì˜¤ë²„ í™”ë©´
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = 'red';
                    ctx.font = '48px Arial';
                    ctx.fillText('ê²Œì„ ì˜¤ë²„!', 250, 200);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '24px Arial';
                    ctx.fillText(`ìµœì¢… ì ìˆ˜: ${gameState.score}`, 300, 250);
                    ctx.fillText(`ë„ë‹¬í•œ ë‚˜ë¬´: ${gameState.treeCount}ê°œ`, 280, 280);
                    ctx.fillText(`ìµœê³  ì½¤ë³´: ${gameState.combo}`, 280, 310);
                    ctx.fillText(`ë ˆë²¨: ${gameState.level}`, 280, 340);
                    ctx.fillText('ìƒˆë¡œê³ ì¹¨í•˜ì—¬ ë‹¤ì‹œ ì‹œì‘', 250, 380);
                }
                return;
            }
            
            // í™”ë©´ í´ë¦¬ì–´
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ë°°ê²½ ê·¸ë¦¬ê¸°
            drawBackground();

            // ê²Œì„ ìš”ì†Œ ì—…ë°ì´íŠ¸
            updateMonkey();
            updateFire();

            checkCollisions();
            checkGameOver();
            
            // ê²Œì„ ìš”ì†Œ ê·¸ë¦¬ê¸°
            drawTrees();
            drawBananas();
            drawInvincibilityItems();
            drawMonkey();
            drawParticles();
            drawFireParticles();
            drawSmokeParticles();
            
            // UI ì—…ë°ì´íŠ¸
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ê²Œì„ ì‹œì‘
        console.log("ğŸ’ ì›ìˆ­ì´ì˜ ì‚°ë¶ˆ íƒˆì¶œ ê²Œì„ ì‹œì‘!");
        document.getElementById('highScore').textContent = gameState.highScore;
    </script>
</body>
</html> 